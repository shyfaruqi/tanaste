@namespace Tanaste.Web.Components.Settings
@inject UIOrchestratorService Orchestrator
@inject ISnackbar Snackbar
@implements IDisposable

@* Folder configuration — Watch Folder + Library Folder with health status dots. *@

<MudPaper Elevation="0" Style="@GlassStyle">

    <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-2">
        <MudIcon Icon="@Icons.Material.Outlined.FolderOpen" Color="Color.Primary" Class="mr-2" />
        <MudText Typo="Typo.h6">File Management</MudText>
    </MudStack>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-6">
        Tell me where to find and keep your media.
    </MudText>

    @* Watch Folder *@
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-1">
        <MudIcon Icon="@Icons.Material.Filled.Circle"
                 Size="Size.Small"
                 Color="@(_watchHealthy ? Color.Success : Color.Error)" />
        <MudText Typo="Typo.subtitle2">Watch Folder</MudText>
    </MudStack>
    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
        Where should I look for new files?
    </MudText>
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudTextField @bind-Value="_watchDir"
                      Placeholder="/path/to/watch"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      Margin="Margin.Dense" />
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Primary"
                   OnClick="@TestWatchPathAsync"
                   Disabled="@(string.IsNullOrWhiteSpace(_watchDir) || _testingWatch)"
                   Style="white-space: nowrap; min-width: 110px;">
            @(_testingWatch ? "Testing..." : "Test Path")
        </MudButton>
    </MudStack>
    @if (_watchTestResult is not null)
    {
        <MudChip T="string"
                 Color="@GetTestColor(_watchTestResult)"
                 Size="Size.Small"
                 Class="mb-5">
            @GetTestLabel(_watchTestResult)
        </MudChip>
    }
    else
    {
        <div class="mb-5" />
    }

    @* Library Folder *@
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1" Class="mb-1">
        <MudIcon Icon="@Icons.Material.Filled.Circle"
                 Size="Size.Small"
                 Color="@(_libraryHealthy ? Color.Success : Color.Error)" />
        <MudText Typo="Typo.subtitle2">Library Folder</MudText>
    </MudStack>
    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
        Where should my organised library live?
    </MudText>
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudTextField @bind-Value="_libraryRoot"
                      Placeholder="/path/to/library"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      Margin="Margin.Dense" />
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Primary"
                   OnClick="@TestLibraryPathAsync"
                   Disabled="@(string.IsNullOrWhiteSpace(_libraryRoot) || _testingLib)"
                   Style="white-space: nowrap; min-width: 110px;">
            @(_testingLib ? "Testing..." : "Test Path")
        </MudButton>
    </MudStack>
    @if (_libTestResult is not null)
    {
        <MudChip T="string"
                 Color="@GetTestColor(_libTestResult)"
                 Size="Size.Small"
                 Class="mb-5">
            @GetTestLabel(_libTestResult)
        </MudChip>
    }
    else
    {
        <div class="mb-5" />
    }

    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               FullWidth="true"
               OnClick="@SaveFoldersAsync"
               Disabled="@_savingFolders">
        @(_savingFolders ? "Saving..." : "Save Changes")
    </MudButton>

</MudPaper>

@code {

    private const string GlassStyle =
        "background: var(--tanaste-glass-bg); " +
        "border: 1px solid var(--tanaste-glass-border); " +
        "backdrop-filter: blur(10px); " +
        "-webkit-backdrop-filter: blur(10px); " +
        "border-radius: 32px; " +
        "padding: 32px;";

    // ── State ────────────────────────────────────────────────────────────────────

    private string              _watchDir       = string.Empty;
    private string              _libraryRoot    = string.Empty;
    private PathTestResultDto?  _watchTestResult;
    private PathTestResultDto?  _libTestResult;
    private bool                _testingWatch;
    private bool                _testingLib;
    private bool                _savingFolders;
    private bool                _watchHealthy;
    private bool                _libraryHealthy;

    // ── Lifecycle ────────────────────────────────────────────────────────────────

    protected override async Task OnInitializedAsync()
    {
        var settings = await Orchestrator.GetFolderSettingsAsync();
        if (settings is not null)
        {
            _watchDir    = settings.WatchDirectory;
            _libraryRoot = settings.LibraryRoot;
        }

        // Run initial health checks based on current folder settings.
        await CheckInitialHealthAsync();

        Orchestrator.OnFolderHealthChanged += HandleFolderHealthChanged;
    }

    public void Dispose()
    {
        Orchestrator.OnFolderHealthChanged -= HandleFolderHealthChanged;
    }

    // ── Folder health event ─────────────────────────────────────────────────────

    private void HandleFolderHealthChanged(string path, bool healthy)
    {
        if (!string.IsNullOrWhiteSpace(_watchDir)
            && string.Equals(path, _watchDir, StringComparison.OrdinalIgnoreCase))
            _watchHealthy = healthy;
        else if (!string.IsNullOrWhiteSpace(_libraryRoot)
            && string.Equals(path, _libraryRoot, StringComparison.OrdinalIgnoreCase))
            _libraryHealthy = healthy;

        InvokeAsync(StateHasChanged);
    }

    private async Task CheckInitialHealthAsync()
    {
        if (!string.IsNullOrWhiteSpace(_watchDir))
        {
            var r = await Orchestrator.TestPathAsync(_watchDir);
            _watchHealthy = r is { Exists: true, HasRead: true, HasWrite: true };
        }

        if (!string.IsNullOrWhiteSpace(_libraryRoot))
        {
            var r = await Orchestrator.TestPathAsync(_libraryRoot);
            _libraryHealthy = r is { Exists: true, HasRead: true, HasWrite: true };
        }
    }

    // ── Handlers ─────────────────────────────────────────────────────────────────

    private async Task TestWatchPathAsync()
    {
        if (string.IsNullOrWhiteSpace(_watchDir)) return;
        _testingWatch    = true;
        _watchTestResult = await Orchestrator.TestPathAsync(_watchDir);
        _testingWatch    = false;

        if (_watchTestResult is null)
        {
            Snackbar.Add("Cannot reach the Engine — please make sure it is running.", Severity.Error);
            _watchHealthy = false;
        }
        else
        {
            _watchHealthy = _watchTestResult is { Exists: true, HasRead: true, HasWrite: true };
        }
    }

    private async Task TestLibraryPathAsync()
    {
        if (string.IsNullOrWhiteSpace(_libraryRoot)) return;
        _testingLib    = true;
        _libTestResult = await Orchestrator.TestPathAsync(_libraryRoot);
        _testingLib    = false;

        if (_libTestResult is null)
        {
            Snackbar.Add("Cannot reach the Engine — please make sure it is running.", Severity.Error);
            _libraryHealthy = false;
        }
        else
        {
            _libraryHealthy = _libTestResult is { Exists: true, HasRead: true, HasWrite: true };
        }
    }

    private async Task SaveFoldersAsync()
    {
        _savingFolders = true;

        // Pre-flight: check that the Engine is reachable before validating paths.
        var engineStatus = await Orchestrator.GetSystemStatusAsync();
        if (engineStatus is null)
        {
            Snackbar.Add("Cannot reach the Engine — please make sure it is running.", Severity.Error);
            _savingFolders = false;
            return;
        }

        // Validate Watch Folder (required — must have read + write).
        if (!string.IsNullOrWhiteSpace(_watchDir))
        {
            var r = await Orchestrator.TestPathAsync(_watchDir);
            _watchTestResult = r;
            if (r is null)
            {
                Snackbar.Add("Cannot reach the Engine — please make sure it is running.", Severity.Error);
                _savingFolders = false;
                return;
            }
            if (r is not { HasRead: true, HasWrite: true })
            {
                Snackbar.Add("Watch Folder is not accessible — please check the path and permissions.",
                    Severity.Error);
                _watchHealthy  = false;
                _savingFolders = false;
                return;
            }
            _watchHealthy = true;
        }

        // Validate Library Folder (optional — if provided, must have read + write).
        if (!string.IsNullOrWhiteSpace(_libraryRoot))
        {
            var r = await Orchestrator.TestPathAsync(_libraryRoot);
            _libTestResult = r;
            if (r is null)
            {
                Snackbar.Add("Cannot reach the Engine — please make sure it is running.", Severity.Error);
                _savingFolders = false;
                return;
            }
            if (r is not { HasRead: true, HasWrite: true })
            {
                Snackbar.Add("Library Folder is not accessible — please check the path and permissions.",
                    Severity.Error);
                _libraryHealthy = false;
                _savingFolders  = false;
                return;
            }
            _libraryHealthy = true;
        }

        var dto     = new FolderSettingsDto(_watchDir, _libraryRoot);
        var success = await Orchestrator.UpdateFolderSettingsAsync(dto);

        if (success)
        {
            Snackbar.Add($"Watch Folder active — now watching {_watchDir}", Severity.Success);
        }
        else
        {
            var detail = Orchestrator.LastApiError;
            Snackbar.Add(
                string.IsNullOrEmpty(detail)
                    ? "Could not save folder settings — please make sure the Engine is running."
                    : $"Could not save: {detail}",
                Severity.Error);
        }

        _savingFolders = false;
    }

    private static Color GetTestColor(PathTestResultDto r) =>
        !r.Exists              ? Color.Error   :
        r.HasRead && r.HasWrite ? Color.Success :
                                  Color.Warning;

    private static string GetTestLabel(PathTestResultDto r) =>
        !r.Exists               ? "Folder not found"              :
        r.HasRead && r.HasWrite  ? "Read & Write access confirmed" :
        r.HasRead               ? "Read only — cannot write"      :
                                   "Access denied";
}
