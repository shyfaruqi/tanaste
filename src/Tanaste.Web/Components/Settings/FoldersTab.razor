@namespace Tanaste.Web.Components.Settings
@inject UIOrchestratorService Orchestrator
@inject ISnackbar Snackbar

@* Folder configuration — Watch Folder + Library Folder. *@

<MudPaper Elevation="0" Style="@GlassStyle">

    <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-2">
        <MudIcon Icon="@Icons.Material.Outlined.FolderOpen" Color="Color.Primary" Class="mr-2" />
        <MudText Typo="Typo.h6">File Management</MudText>
    </MudStack>
    <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-6">
        Tell me where to find and keep your media.
    </MudText>

    @* Watch Folder *@
    <MudText Typo="Typo.subtitle2" Class="mb-1">Watch Folder</MudText>
    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
        Where should I look for new files?
    </MudText>
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudTextField @bind-Value="_watchDir"
                      Placeholder="/path/to/watch"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      Margin="Margin.Dense" />
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Primary"
                   OnClick="@TestWatchPathAsync"
                   Disabled="@(string.IsNullOrWhiteSpace(_watchDir) || _testingWatch)"
                   Style="white-space: nowrap; min-width: 110px;">
            @(_testingWatch ? "Testing…" : "Test Path")
        </MudButton>
    </MudStack>
    @if (_watchTestResult is not null)
    {
        <MudChip T="string"
                 Color="@GetTestColor(_watchTestResult)"
                 Size="Size.Small"
                 Class="mb-5">
            @GetTestLabel(_watchTestResult)
        </MudChip>
    }
    else
    {
        <div class="mb-5" />
    }

    @* Library Folder *@
    <MudText Typo="Typo.subtitle2" Class="mb-1">Library Folder</MudText>
    <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mb-2">
        Where should my organised library live?
    </MudText>
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudTextField @bind-Value="_libraryRoot"
                      Placeholder="/path/to/library"
                      Variant="Variant.Outlined"
                      FullWidth="true"
                      Immediate="true"
                      Margin="Margin.Dense" />
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Primary"
                   OnClick="@TestLibraryPathAsync"
                   Disabled="@(string.IsNullOrWhiteSpace(_libraryRoot) || _testingLib)"
                   Style="white-space: nowrap; min-width: 110px;">
            @(_testingLib ? "Testing…" : "Test Path")
        </MudButton>
    </MudStack>
    @if (_libTestResult is not null)
    {
        <MudChip T="string"
                 Color="@GetTestColor(_libTestResult)"
                 Size="Size.Small"
                 Class="mb-5">
            @GetTestLabel(_libTestResult)
        </MudChip>
    }
    else
    {
        <div class="mb-5" />
    }

    <MudButton Variant="Variant.Filled"
               Color="Color.Primary"
               FullWidth="true"
               OnClick="@SaveFoldersAsync"
               Disabled="@_savingFolders">
        @(_savingFolders ? "Saving…" : "Save Changes")
    </MudButton>

</MudPaper>

@code {

    private const string GlassStyle =
        "background: rgba(22,22,36,0.55); " +
        "border: 1px solid rgba(255,255,255,0.08); " +
        "backdrop-filter: blur(10px); " +
        "-webkit-backdrop-filter: blur(10px); " +
        "border-radius: 24px; " +
        "padding: 32px;";

    // ── State ────────────────────────────────────────────────────────────────────

    private string              _watchDir       = string.Empty;
    private string              _libraryRoot    = string.Empty;
    private PathTestResultDto?  _watchTestResult;
    private PathTestResultDto?  _libTestResult;
    private bool                _testingWatch;
    private bool                _testingLib;
    private bool                _savingFolders;

    // ── Lifecycle ────────────────────────────────────────────────────────────────

    protected override async Task OnInitializedAsync()
    {
        var settings = await Orchestrator.GetFolderSettingsAsync();
        if (settings is not null)
        {
            _watchDir    = settings.WatchDirectory;
            _libraryRoot = settings.LibraryRoot;
        }
    }

    // ── Handlers ─────────────────────────────────────────────────────────────────

    private async Task TestWatchPathAsync()
    {
        if (string.IsNullOrWhiteSpace(_watchDir)) return;
        _testingWatch    = true;
        _watchTestResult = await Orchestrator.TestPathAsync(_watchDir);
        _testingWatch    = false;
    }

    private async Task TestLibraryPathAsync()
    {
        if (string.IsNullOrWhiteSpace(_libraryRoot)) return;
        _testingLib    = true;
        _libTestResult = await Orchestrator.TestPathAsync(_libraryRoot);
        _testingLib    = false;
    }

    private async Task SaveFoldersAsync()
    {
        _savingFolders = true;

        // Validate Watch Folder (required — must have read + write).
        if (!string.IsNullOrWhiteSpace(_watchDir))
        {
            var r = await Orchestrator.TestPathAsync(_watchDir);
            _watchTestResult = r;
            if (r is not { HasRead: true, HasWrite: true })
            {
                Snackbar.Add("Watch Folder is not accessible — please check the path and permissions.",
                    Severity.Error);
                _savingFolders = false;
                return;
            }
        }

        // Validate Library Folder (optional — if provided, must have read + write).
        if (!string.IsNullOrWhiteSpace(_libraryRoot))
        {
            var r = await Orchestrator.TestPathAsync(_libraryRoot);
            _libTestResult = r;
            if (r is not { HasRead: true, HasWrite: true })
            {
                Snackbar.Add("Library Folder is not accessible — please check the path and permissions.",
                    Severity.Error);
                _savingFolders = false;
                return;
            }
        }

        var dto     = new FolderSettingsDto(_watchDir, _libraryRoot);
        var success = await Orchestrator.UpdateFolderSettingsAsync(dto);

        if (success)
            Snackbar.Add($"Watch Folder active — now watching {_watchDir}", Severity.Success);
        else
            Snackbar.Add("Could not save folder settings — is the Engine running?", Severity.Error);

        _savingFolders = false;
    }

    private static Color GetTestColor(PathTestResultDto r) =>
        !r.Exists              ? Color.Error   :
        r.HasRead && r.HasWrite ? Color.Success :
                                  Color.Warning;

    private static string GetTestLabel(PathTestResultDto r) =>
        !r.Exists               ? "Folder not found"              :
        r.HasRead && r.HasWrite  ? "Read & Write access confirmed" :
        r.HasRead               ? "Read only — cannot write"      :
                                   "Access denied";
}
